#ifndef ADSR_h
#define ADSR_h
#include "Arduino.h"
#include <avr/pgmspace.h>    //to store values in progmem

#define uint32Max 4294967295

//note that this is generated specifically for a clockfrequency of 3125, ranges from 0 tot 10000ms
/*const uint16_t StepsConversionArray[128] PROGMEM = {0,3,12,25,44,67,94,126,163,204,249,298,352,410,472,538,609,683,761,844,930,1020,1115,1213,1315,1422,1532,1646,1763,1885,2011,2140,2273,2410,2551,2695,2844,2996,3152,3311,3474,3641,3812,3987,4165,4346,4532,4721,4914,5110,5310,5514,5722,5933,6147,6366,6587,6813,7042,7274,7511,7751,7994,8241,8491,8745,9003,9264,9529,9797,10069,10344,10623,10905,11191,11480,11773,12069,12369,12672,12979,13289,13603,13920,14240,14564,14892,15223,15557,15895,16236,16581,16929,17281,17636,17994,18356,18721,19090,19462,19837,20216,20599,20984,21373,21766,22162,22561,22963,23369,23779,24191,24607,25027,25450,25876,26305,26738,27174,27614,28057,28503,28952,29405,29861,30321,30784,31250
};*/

//tryout for larger, replace read word with dword
const uint32_t StepsConversionArray[128] PROGMEM = {0, 3, 15, 36, 69, 114, 171, 241, 325, 423, 535, 662, 804, 961, 1134, 1323, 1529, 1750, 1989, 2244, 2516, 2806, 3113, 3438, 3781, 4142, 4521, 4919, 5335, 5770, 6224, 6697, 7189, 7701, 8232, 8782, 9353, 9943, 10553, 11184, 11834, 12505, 13197, 13909, 14642, 15396, 16170, 16966, 17783, 18621, 19480, 20361, 21264, 22188, 23134, 24102, 25092, 26104, 27138, 28194, 29272, 30373, 31497, 32642, 33811, 35002, 36217, 37454, 38714, 39997, 41303, 42633, 43986, 45362, 46762, 48185, 49632, 51102, 52596, 54114, 55656, 57222, 58812, 60426, 62064, 63727, 65413, 67124, 68860, 70620, 72405, 74214, 76048, 77906, 79790, 81698, 83631, 85590, 87573, 89582, 91615, 93674, 95758, 97868, 100003, 102163, 104349, 106561, 108798, 111061, 113350, 115664, 118005, 120371, 122763, 125182, 127626, 130096, 132593, 135116, 137665, 140241, 142843, 145471, 148126, 150807, 153515, 156250
};

class ADSR{
  public:
    ADSR();
    byte Update();
    void Set(byte attackTime, byte decayTime, byte sustainValue, byte releaseTime);
    void Attack();
    void Release();
    void Reset();
  private:
    uint32_t AttackDelta;
    uint32_t DecayDelta;
    byte Sustain;
    uint32_t ReleaseDelta;
    uint32_t Accumulator;
    byte ADSRstatus; //0 = off, 1 = attack, 2 = decay, 3 = sustain, 4 = release
    
    byte updateAttack();
    byte updateDecay();
    byte updateRelease();
    
    uint32_t calculateAttackTime(byte attackTime);
    uint32_t calculateDecayTime(byte decayTime);
    uint32_t calculateReleaseTime(byte releaseTime);

};

#endif
